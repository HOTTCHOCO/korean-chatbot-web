{
  "rules": [
    {
      "type": "prd",
      "content": "# PRD: 韓国とも (Kankoku-Tomo) v0.1\n작성일: 2025-08-06\n작성자: CHAN & Microsoft PM Assistant\n\n## 1. 개요\n한국어를 공부하는 일본인 중급자 이상 학습자가 ‘절친’ 챗봇과 대화하며 실시간 Q&A를 해결하고, 따뜻한 정서적 교류를 경험하도록 돕는 웹 기반 서비스.\n\n## 2. 목표 및 KPI\n| KPI | 목표치 |\n| --- | --- |\n| DAU | ≥ 50명 |\n| 평균 응답 속도 | ≤ 5초 |\n| 평균 세션 길이 | ≥ 5분 |\n| 학습 만족도(설문) | ≥ 4.0/5 |\n\n## 3. 타겟 사용자\n1. 20–30대 일본인 여성 중급 이상 한국어 학습자 (Primary)\n2. 한국 취업·유학을 준비하는 일본인 대학생·직장인 (Secondary)\n\n공통 특성: 실시간 질문 해결이 시급, 정서적 유대감 요구, 문화적 맥락 정보 필요.\n\n## 4. 사용자 목표\n- (Main) 한국어 관련 궁금증을 즉시 해결하고 복습 효율화(B)\n- (Sub) 실력 향상(A), 학습 동기 유지(D)\n\n## 5. 사용자 페르소나 – “절친”\n- 성격: 다정하고 친절한 언니 같은 존재\n- 말투: 존댓말, 따뜻한 톤 (“그런 표현도 참 예뻐요. 혹시 이 표현도 궁금하신가요?”)\n\n## 6. 핵심 기능 (MVP)\n1. 실시간 한국어 Q&A 챗 (GPT-4o API)\n2. 예문 자동 제공\n3. 대화 로그 저장·재열람(로그인 기반)\n\n## 7. 보조 기능 (우선순위 High → Low)\n1. 감정 분석 기반 반응 조절\n2. 음성 입력 & 발음 피드백 *(기술 검토 후 단계적 도입)*\n3. 오프라인 모임(OROSHI) 추천 연동 *(Post-MVP)*\n4. 학습 포인트·배지 시스템 *(Post-MVP)*\n\n## 8. 주요 사용 시나리오\n1. 사용자는 로그인 후 챗 화면에 질문 입력 → 5초 내 답변 & 예문 수신\n2. 챗봇이 추가 학습 질문 제안 → 사용자가 수락 시 대화 지속\n3. 세션 종료 후 ‘대화 기록’ 탭에서 내용 복습 → 즐겨찾기 표시\n\n## 9. Pain Points & 해결 방안\n| Pain Point | 해결 기능 |\n| --- | --- |\n| 즉각적·정확한 답변 부족 | GPT-API 실시간 Q&A |\n| 온라인 학습 고립감 | 감정 분석 + 따뜻한 톤 챗봇 |\n| 복습 비효율 | 대화 로그 저장, 예문 즐겨찾기 |\n| 문화 정보 부족 | 문화 상담 응답, 모임 추천 |\n\n## 10. 기술 스펙 (초안)\n- Platform: Web (React)\n- Backend: Node.js + Express (REST) *(Simple, JS fullstack)*\n- DB: Supabase/PostgreSQL (호스팅 & Auth 포함)\n- AI: OpenAI GPT-4o API, Sentiment API\n- Voice: Web Speech API (검토)\n\n## 11. 개발 전략\n- **MVP 우선** (8/20 출시 목표)\n  - Sprint 0: 환경 세팅 & 기본 UI (8/07–8/09)\n  - Sprint 1: 실시간 Q&A + 예문 제공 (8/10–8/14)\n  - Sprint 2: 로그인 & 로그 저장 (8/15–8/18)\n  - Sprint 3: 감정 반응, 배포, QA (8/19–8/20)\n\n## 12. 데이터 & 보안\n- 일본 개인정보보호법 준수, 최소 정보(email, pw, nickname)\n- 대화 로그 익명 처리, 학습 개선 외 재사용 금지\n\n## 13. 운영 & 모니터링\n- AWS CloudWatch / Supabase Log → 응답 속도·에러율 추적\n- 피드백 폼 연결(영어/일본어)\n- Fallback 메시지: “죄송해요, 조금 더 공부해볼게요!”\n\n## 14. 향후 로드맵\n- 발음 교정 AI & 음성 입력\n- 통계 피드백(“72%가 궁금해했어요”) \n- 구독제 1:1 튜터 / 오프라인 모임 우선권\n- 모바일 앱 (PWA→Native)\n",
      "writedAt": "2025-08-07T03:09:53.739Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD): 韓国とも (Kankoku-Tomo) v0.1\n\n## 1. Executive Technical Summary\n- **Project Overview**: '韓国とも(Kankoku-Tomo)'는 일본인 중급 한국어 학습자를 위한 웹 기반 AI 챗봇 서비스입니다. React 기반의 단일 페이지 애플리케이션(SPA)과 Node.js/Express 백엔드 서버를 통해 신속한 개발과 배포를 지향합니다. 백엔드 인프라는 Supabase를 활용하여 데이터베이스, 인증, 실시간 기능을 통합 관리함으로써 개발 복잡성을 최소화하고 운영 효율성을 극대화합니다.\n- **Core Technology Stack**: 프론트엔드는 React, 백엔드는 Node.js와 Express를 사용합니다. 데이터베이스와 인증은 Supabase(PostgreSQL)가 담당하며, 핵심 AI 기능은 OpenAI의 GPT-4o API를 활용합니다.\n- **Key Technical Objectives**:\n    - **응답 속도**: 사용자의 질문에 대해 5초 이내에 AI 답변을 제공합니다.\n    - **안정성**: 99% 이상의 서비스 가동 시간을 목표로 합니다.\n    - **확장성**: 초기 DAU 50명을 무리 없이 처리하고, 향후 사용자 증가에 유연하게 대응할 수 있는 아키텍처를 구축합니다.\n- **Critical Technical Assumptions**:\n    - OpenAI GPT-4o API의 응답 속도와 품질이 사용자의 기대치를 충족합니다.\n    - Supabase의 무료/저가 플랜이 MVP 단계의 트래픽과 데이터 저장 요구사항을 충분히 감당할 수 있습니다.\n    - 웹 표준 기술(Web Speech API)이 주요 타겟 브라우저(Chrome, Safari)에서 안정적으로 동작합니다.\n\n## 2. Tech Stack\n\n| Category | Technology / Library | Reasoning (Why it's chosen for this project) |\n|---|---|---|\n| **Frontend** | React, Vite | 컴포넌트 기반 아키텍처로 UI 개발 및 유지보수가 용이하며, 생태계가 활성화되어 있습니다. Vite는 빠른 개발 서버와 최적화된 빌드 성능을 제공합니다. |\n| **Backend** | Node.js, Express.js | 프론트엔드와 동일한 JavaScript/TypeScript 언어를 사용하여 풀스택 개발 생산성을 높입니다. 가볍고 최소한의 구성으로 REST API를 빠르게 구축할 수 있습니다. |\n| **Database & Auth** | Supabase (PostgreSQL) | 관리형 PostgreSQL 데이터베이스와 인증(Auth), 스토리지 기능을 통합 제공하여 백엔드 개발 리소스를 크게 절감합니다. 실시간 기능(Realtime)을 통해 향후 기능 확장이 용이합니다. |\n| **AI / ML** | OpenAI GPT-4o API | 사용자의 질문에 대한 자연스럽고 정확한 답변 및 예문 생성을 위해 검증된 최신 언어 모델을 사용합니다. |\n| **AI / ML (감정 분석)** | 외부 Sentiment Analysis API (예: Vercel AI SDK 연동) | 챗봇의 응답에 감성적 깊이를 더하기 위해 전문 API를 활용합니다. Vercel AI SDK와 통합하여 구현을 단순화합니다. |\n| **Deployment** | Vercel (Frontend), Render (Backend) | Git과 연동된 자동 CI/CD 파이프라인을 통해 배포를 자동화합니다. Vercel은 React 앱 배포에 최적화되어 있고, Render는 Node.js 서버와 PostgreSQL(Supabase 연동) 환경을 손쉽게 구성할 수 있습니다. |\n| **State Management** | Zustand | 가볍고 직관적인 API를 제공하여 React 상태 관리를 단순화합니다. Boilerplate 코드가 적어 소규모 프로젝트에 적합합니다. |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Client (React Web App)**: 사용자가 직접 상호작용하는 웹 애플리케이션입니다. 사용자 인터페이스(UI), 상태 관리, 사용자 입력을 처리합니다.\n    - **Sub-building blocks**: Chat Interface, Authentication Pages (Login/Signup), Conversation History View.\n- **Backend (Node.js API Server)**: 비즈니스 로직을 처리하고 외부 서비스와의 통신을 중계하는 서버입니다. 클라이언트와 데이터베이스 사이의 게이트웨이 역할을 합니다.\n    - **Sub-building blocks**: REST API Endpoints, OpenAI API Integration Logic, User Session Management.\n- **BaaS (Supabase)**: 백엔드 핵심 기능을 제공하는 서비스형 백엔드(Backend-as-a-Service)입니다. 데이터베이스, 사용자 인증, 파일 스토리지를 담당합니다.\n    - **Sub-building blocks**: PostgreSQL Database, User Authentication, Row Level Security (RLS).\n- **External AI Services**: 서비스의 핵심 지능을 제공하는 외부 API입니다.\n    - **Sub-building blocks**: OpenAI API, Sentiment Analysis API.\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    subgraph Browser\n        User[사용자]\n    end\n\n    subgraph Vercel\n        Client[React Web App]\n    end\n\n    subgraph Render\n        Backend[Node.js API Server]\n    end\n    \n    subgraph External Services\n        OpenAI[OpenAI GPT-4o API]\n        Sentiment[Sentiment Analysis API]\n    end\n\n    subgraph Supabase Cloud\n        Auth[Supabase Auth]\n        DB[PostgreSQL Database]\n    end\n\n    User -- Interacts with --> Client\n    Client -- REST API Calls (질문, 기록 조회) --> Backend\n    Client -- Auth Requests (로그인, 가입) --> Auth\n    Backend -- AI Query --> OpenAI\n    Backend -- Sentiment Analysis --> Sentiment\n    Backend -- DB Operations (대화 저장/조회) --> DB\n```\n\n- 사용자는 Vercel에 배포된 React 웹 앱과 상호작용합니다.\n- 로그인/회원가입과 같은 인증 요청은 클라이언트에서 직접 Supabase Auth로 전송되어 처리됩니다.\n- 채팅 메시지 전송과 같은 핵심 기능 요청은 Render에 배포된 Node.js 백엔드 서버로 전달됩니다.\n- 백엔드 서버는 OpenAI API와 Sentiment API를 호출하여 AI 응답을 생성하고, 대화 내용을 Supabase 데이터베이스에 저장/조회합니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 비즈니스 도메인(예: 채팅, 사용자, 기록)을 기준으로 코드를 구성하여 응집도를 높이고 결합도를 낮춥니다.\n- **Layer-Based Architecture**: 각 도메인 내부는 Presentation(Controller), Business Logic(Service), Data Access(Repository) 계층으로 분리하여 관심사를 명확히 합니다.\n- **Feature-Based Modules**: 프론트엔드는 기능 단위(예: `features/chat`, `features/auth`)로 컴포넌트, 상태, 훅을 그룹화합니다.\n- **Shared Components**: 여러 도메인에서 공통으로 사용되는 유틸리티, 타입 정의, UI 컴포넌트는 `shared` 또는 `lib` 디렉토리에서 관리합니다.\n\n**Universal File & Folder Structure**\n```\n/\n├── frontend/ (React Client)\n│   ├── src/\n│   │   ├── api/             # API 호출 함수\n│   │   ├── assets/          # 이미지, 폰트\n│   │   ├── components/      # 재사용 가능한 UI 컴포넌트 (Atoms, Molecules)\n│   │   │   ├── ui/          # Headless UI 기반의 기본 컴포넌트\n│   │   │   └── layout/      # 페이지 레이아웃\n│   │   ├── features/        # 기능별 도메인 폴더\n│   │   │   ├── auth/        # 인증 관련 컴포넌트, 훅\n│   │   │   └── chat/        # 채팅 관련 컴포넌트, 훅, 상태\n│   │   ├── hooks/           # 공용 커스텀 훅\n│   │   ├── pages/           # 라우팅 단위 페이지\n│   │   ├── store/           # 전역 상태 관리 (Zustand)\n│   │   └── App.tsx\n│   └── package.json\n│\n├── backend/ (Node.js Server)\n│   ├── src/\n│   │   ├── common/          # 공통 모듈 (미들웨어, 유틸리티)\n│   │   ├── config/          # 환경변수, 설정\n│   │   ├── domains/         # 비즈니스 도메인별 폴더\n│   │   │   ├── chat/\n│   │   │   │   ├── chat.controller.ts # HTTP 요청/응답 처리\n│   │   │   │   ├── chat.service.ts    # 비즈니스 로직\n│   │   │   │   └── chat.router.ts     # 라우팅 설정\n│   │   │   └── user/\n│   │   ├── lib/             # 외부 서비스 연동 클라이언트 (OpenAI)\n│   │   └── server.ts        # 서버 진입점\n│   └── package.json\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: 클라이언트와 백엔드 서버 간의 통신은 HTTPS 기반의 RESTful API를 통해 이루어지며, 데이터 형식은 JSON을 사용합니다.\n- **Database Interaction**: 백엔드 서버는 Supabase 클라이언트 라이브러리 또는 Prisma와 같은 ORM을 사용하여 PostgreSQL 데이터베이스와 상호작용합니다. 데이터 접근 시 Supabase의 RLS(Row Level Security) 정책을 준수하여 사용자별 데이터 격리를 보장합니다.\n- **External Service Integration**: 백엔드 서버가 클라이언트를 대신하여 OpenAI, Sentiment API 등을 호출하는 프록시 역할을 수행합니다. 이를 통해 API Key와 같은 민감한 정보를 안전하게 관리합니다.\n- **Real-time Communication**: MVP에서는 실시간 통신이 필수적이지 않으나, 향후 기능 확장 시 Supabase Realtime 또는 WebSocket을 도입하여 \"상대방 입력 중...\"과 같은 기능을 구현할 수 있습니다.\n- **Data Synchronization**: 사용자 인증 상태는 Supabase Auth가 발급하는 JWT(JSON Web Token)를 통해 클라이언트와 서버 간에 동기화됩니다. 대화 기록은 필요시 API를 통해 명시적으로 조회합니다.\n\n## 4. Performance & Optimization Strategy\n\n- **AI 응답 속도 최적화**: OpenAI API 호출 시 `stream: true` 옵션을 사용하여 응답을 스트리밍 방식으로 수신합니다. 이를 통해 사용자는 전체 답변이 생성될 때까지 기다리지 않고, 생성되는 텍스트를 실시간으로 볼 수 있어 체감 속도를 크게 향상시킬 수 있습니다.\n- **프론트엔드 로딩 성능 개선**: React.lazy와 Suspense를 활용하여 코드 스플리팅을 적용합니다. 초기 로딩에 필요하지 않은 컴포넌트(예: 대화 기록 페이지)는 사용자가 해당 페이지로 이동할 때 동적으로 로드하여 초기 번들 크기를 줄입니다.\n- **데이터베이스 쿼리 효율화**: 대화 기록을 조회하는 쿼리에 `user_id`와 `created_at` 필드를 기준으로 인덱스(Index)를 생성하여 대량의 데이터가 쌓여도 빠른 조회 성능을 보장합니다.\n- **정적 자산 캐싱**: Vercel의 글로벌 CDN(Content Delivery Network)을 활용하여 이미지, CSS, JS 파일과 같은 정적 자산을 사용자에게 가장 가까운 엣지 로케이션에서 제공함으로써 로딩 속도를 단축합니다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Supabase 프로젝트 생성, 데이터베이스 스키마(users, conversations, messages) 설계, Vercel/Render 배포 환경 구성.\n- **Essential Features**:\n    - 이메일 기반 회원가입 및 로그인 (Supabase Auth 연동)\n    - 실시간 Q&A 채팅 인터페이스 구현\n    - 백엔드를 통한 OpenAI GPT-4o API 연동 (질문->답변+예문)\n    - 대화 로그 저장 및 재열람 기능\n- **Basic Security**: Supabase RLS를 설정하여 사용자는 자신의 대화 기록만 접근 가능하도록 제한. API Key 등 민감 정보는 환경변수로 관리.\n- **Development Setup**: Git 레포지토리 생성, 프론트엔드/백엔드 개발 환경 구축, CI/CD 파이프라인 설정.\n- **Timeline**: 2.5주 (PRD의 8/7 ~ 8/20 일정 준수)\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**:\n    - 감정 분석 API를 연동하여 챗봇의 공감 반응 기능 구현\n    - Web Speech API를 활용한 음성 입력 기능 기술 검토 및 프로토타입 개발\n- **Performance Optimization**: MVP 운영 데이터 기반으로 느린 API 엔드포인트 및 DB 쿼리 튜닝. 프론트엔드 번들 사이즈 분석 및 최적화.\n- **Enhanced Security**: 서드파티 라이브러리 보안 취약점 점검(npm audit), API 요청 속도 제한(Rate Limiting) 도입.\n- **Monitoring Implementation**: AWS CloudWatch 또는 유사 모니터링 툴을 연동하여 API 응답 시간, 에러율, 서버 리소스 사용량에 대한 대시보드 및 알림 설정.\n- **Timeline**: MVP 출시 후 1개월 내\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**:\n    - **위험**: OpenAI API의 응답 지연 또는 비용 급증. 챗봇의 페르소나(따뜻한 말투)를 일관되게 유지하기 위한 프롬프트 엔지니어링의 복잡성.\n    - **완화 전략**: API 호출에 합리적인 타임아웃(Timeout)을 설정하고, 스트리밍 응답을 적용하여 체감 성능을 개선합니다. 비용 모니터링 알림을 설정하고, 프롬프트는 버전 관리하여 지속적으로 개선합니다.\n- **Performance Risks**:\n    - **위험**: 사용자 및 대화 데이터 증가 시 대화 기록 조회 성능 저하.\n    - **완화 전략**: 데이터베이스 `user_id`, `conversation_id`에 인덱스를 적용하고, 페이지네이션(Pagination)을 구현하여 한 번에 불러오는 데이터 양을 제한합니다.\n- **Security Risks**:\n    - **위험**: Supabase RLS 정책 설정 오류로 인한 데이터 유출. 악의적인 API 요청으로 인한 서비스 장애 또는 비용 발생.\n    - **완화 전략**: RLS 정책에 대한 코드 리뷰 및 테스트를 강화합니다. 백엔드 API에 요청량 제한(Rate Limiting)을 적용하여 DoS 공격을 방지합니다.\n- **Integration Risks**:\n    - **위험**: 외부 API(OpenAI, Sentiment)의 장애 또는 정책 변경으로 인한 서비스 중단.\n    - **완화 전략**: API 호출 로직에 서킷 브레이커(Circuit Breaker) 패턴을 적용하여 장애 전파를 막고, \"죄송해요, 지금은 답변하기 어려워요\"와 같은 안정적인 폴백(Fallback) 메시지를 사용자에게 안내합니다.\n\n### Project Delivery Risks\n- **Timeline Risks**:\n    - **위험**: 2.5주라는 공격적인 MVP 개발 일정으로 인한 기능 구현 지연.\n    - **완화 전략**: Supabase와 같은 BaaS를 적극 활용하여 백엔드 개발 공수를 최소화하고, MVP 범위에서 우선순위가 낮은 기능(예: 정교한 감정 분석)은 과감히 제외합니다.\n- **Resource Risks**:\n    - **위험**: 프롬프트 엔지니어링, Supabase RLS 등 특정 기술에 대한 팀의 경험 부족.\n    - **완화 전략**: 공식 문서와 커뮤니티를 적극 활용하고, 복잡한 로직은 구현 전에 간단한 PoC(Proof of Concept)를 통해 기술을 검증합니다.\n- **Quality Risks**:\n    - **위험**: 빠른 개발 속도로 인한 코드 품질 저하 및 버그 발생 가능성.\n    - **완화 전략**: 인증, 채팅 메시지 처리 등 핵심 로직에 대한 단위 테스트 및 통합 테스트 코드를 작성합니다. 동료 간 코드 리뷰를 의무화하여 잠재적 결함을 조기에 발견합니다.\n- **Deployment Risks**:\n    - **위험**: 개발 환경과 운영 환경의 차이로 인한 배포 후 예상치 못한 오류 발생.\n    - **완화 전략**: Vercel/Render의 개발, 프리뷰, 프로덕션 환경을 분리하여 사용하고, 주요 변경 사항은 프리뷰 환경에서 충분히 검증한 후 프로덕션에 배포합니다.",
      "writedAt": "2025-08-07T03:09:53.740Z"
    },
    {
      "type": "guideline",
      "content": "# Kankoku-Tomo Project: Code Guidelines\n\nThis document outlines the mandatory and recommended coding standards for the Kankoku-Tomo project. Adhering to these guidelines ensures code consistency, maintainability, and quality, facilitating efficient collaboration and future development.\n\n## 1. Project Overview\n\nKankoku-Tomo is a web-based AI chatbot service designed for intermediate Japanese learners of Korean. It provides real-time Q&A, example sentences, and conversation logging, fostering emotional connection through a \"best friend\" persona.\n\n**Key Architectural Decisions:**\n*   **Frontend**: React (SPA) with Vite, Zustand for state management, deployed on Vercel.\n*   **Backend**: Node.js with Express.js, deployed on Render.\n*   **Database & Auth**: Supabase (PostgreSQL) for managed DB and authentication.\n*   **AI/ML**: OpenAI GPT-4o API for core chat, external Sentiment Analysis API.\n*   **Communication**: RESTful API (JSON over HTTPS) between client and backend. Direct Supabase Auth calls from client.\n*   **Organization**: Domain-driven and feature-based code organization. Layered architecture (Presentation, Business Logic, Data Access).\n\n## 2. Core Principles\n\n1.  **User-Centric Performance**: Deliver a responsive and delightful user experience, targeting AI responses within 5 seconds.\n2.  **Simplicity & Maintainability**: Favor clear, straightforward solutions over complex abstractions to ensure rapid development and easy debugging.\n3.  **Security by Design**: Implement robust security practices from the outset, protecting user data and API keys.\n4.  **Modularity & Reusability**: Design components and modules to be independent and reusable, promoting a scalable and organized codebase.\n5.  **Type Safety & Predictability**: Leverage TypeScript comprehensively to catch errors early and improve code clarity.\n\n## 3. Language-Specific Guidelines\n\n### TypeScript (General)\n*   **MUST**: Use TypeScript for all new code. Existing JavaScript files MUST be migrated to TypeScript (`.ts` or `.tsx`) as they are modified.\n*   **MUST**: Enable `strict` mode in `tsconfig.json`.\n*   **MUST**: Define explicit types for function parameters, return values, and complex object structures (e.g., API responses, component props).\n*   **MUST NOT**: Use `any` type unless absolutely necessary and with clear justification (e.g., for third-party libraries without type definitions), and `// @ts-ignore` comments should be avoided.\n\n```typescript\n// MUST: Explicitly type props and return values\ninterface ChatMessageProps {\n  message: {\n    id: string;\n    text: string;\n    sender: 'user' | 'bot';\n    timestamp: string;\n  };\n}\n\nconst ChatMessage = ({ message }: ChatMessageProps): JSX.Element => {\n  // ...\n};\n\n// MUST NOT: Rely on implicit any or loose typing\n// const ChatMessage = (props) => { // 'props' implicitly has an 'any' type.\n//   // ...\n// };\n```\n\n### React (Frontend)\n\n*   **File Organization**:\n    *   **MUST**: Follow the feature-based structure (`src/features/auth`, `src/features/chat`).\n    *   **MUST**: Group related components, hooks, and state within their respective feature folders.\n    *   **MUST**: Place truly reusable UI components (e.g., buttons, inputs) in `src/components/ui`. Layout components in `src/components/layout`.\n    *   **MUST**: Place global state definitions (Zustand stores) in `src/store`.\n    *   **MUST**: Keep page-level components in `src/pages`.\n*   **Import Management**:\n    *   **MUST**: Use absolute imports from `src` for better readability and refactoring. Configure `baseUrl` in `tsconfig.json`.\n\n```typescript\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src\"\n  }\n}\n\n// MUST: Absolute import\nimport { useAuthStore } from 'store/auth';\nimport { Button } from 'components/ui/Button';\n\n// MUST NOT: Relative import hell\n// import { useAuthStore } from '../../../../store/auth';\n```\n\n*   **Error Handling**:\n    *   **MUST**: Implement React Error Boundaries for UI-level errors to prevent the entire application from crashing.\n    *   **MUST**: Use `try-catch` blocks for asynchronous API calls within `useEffect` or event handlers, providing user-friendly feedback.\n    *   **MUST**: Display clear, actionable error messages to the user for failed operations.\n\n```typescript\n// MUST: Error Boundary for UI errors\n// src/components/ErrorBoundary.tsx\nimport React, { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children?: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n}\n\nclass ErrorBoundary extends Component<Props, State> {\n  public state: State = {\n    hasError: false\n  };\n\n  public static getDerivedStateFromError(_: Error): State {\n    return { hasError: true };\n  }\n\n  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error(\"Uncaught error:\", error, errorInfo);\n    // TODO: Log error to a service like Sentry\n  }\n\n  public render() {\n    if (this.state.hasError) {\n      return <h1 className=\"text-red-500\">Something went wrong. Please try again later.</h1>;\n    }\n    return this.props.children;\n  }\n}\n\n// MUST: Use try-catch for API calls\nconst fetchChatHistory = async () => {\n  try {\n    const response = await api.get('/chats');\n    // ...\n  } catch (error) {\n    console.error('Failed to fetch chat history:', error);\n    // MUST: Show user-friendly message\n    alert('Failed to load chat history. Please try again.');\n  }\n};\n```\n\n### Node.js/Express (Backend)\n\n*   **File Organization**:\n    *   **MUST**: Adhere to the domain-driven structure (`src/domains/chat`, `src/domains/user`).\n    *   **MUST**: Separate concerns within each domain:\n        *   `*.controller.ts`: Handles HTTP requests/responses, input validation.\n        *   `*.service.ts`: Contains core business logic, orchestrates data flow.\n        *   `*.router.ts`: Defines API routes and links to controllers.\n    *   **MUST**: Place common utilities and middleware in `src/common`.\n    *   **MUST**: Place external API clients (e.g., OpenAI, Sentiment) in `src/lib`.\n*   **Import Management**:\n    *   **MUST**: Use absolute imports from `src` (similar to frontend).\n*   **Error Handling**:\n    *   **MUST**: Implement a centralized error handling middleware in Express to catch and format errors consistently.\n    *   **MUST**: Define custom error classes for specific business logic errors (e.g., `NotFoundError`, `ValidationError`).\n    *   **MUST**: Log detailed error information (stack traces, request context) for debugging.\n    *   **MUST**: Return standardized JSON error responses to the client (e.g., `{ error: { message: \"...\", code: \"...\" } }`).\n\n```typescript\n// MUST: Custom Error Class\n// src/common/errors.ts\nexport class ApiError extends Error {\n  statusCode: number;\n  errorCode: string;\n\n  constructor(message: string, statusCode: number = 500, errorCode: string = 'SERVER_ERROR') {\n    super(message);\n    this.name = this.constructor.name;\n    this.statusCode = statusCode;\n    this.errorCode = errorCode;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class NotFoundError extends ApiError {\n  constructor(message: string = 'Resource not found') {\n    super(message, 404, 'NOT_FOUND');\n  }\n}\n\n// MUST: Centralized Error Middleware (src/common/errorHandler.ts)\nimport { Request, Response, NextFunction } from 'express';\nimport { ApiError } from './errors';\n\nexport const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) => {\n  if (err instanceof ApiError) {\n    return res.status(err.statusCode).json({\n      error: {\n        message: err.message,\n        code: err.errorCode,\n      },\n    });\n  }\n\n  console.error('Unhandled error:', err); // MUST: Log unhandled errors\n  res.status(500).json({\n    error: {\n      message: 'An unexpected error occurred.',\n      code: 'SERVER_ERROR',\n    },\n  });\n};\n\n// MUST: Use in controllers\n// src/domains/chat/chat.controller.ts\nimport { Request, Response, NextFunction } from 'express';\nimport * as chatService from './chat.service';\nimport { ApiError } from 'common/errors';\n\nexport const getChatHistory = async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const userId = req.user?.id; // Assuming user is attached by auth middleware\n    if (!userId) {\n      throw new ApiError('Authentication required', 401, 'UNAUTHENTICATED');\n    }\n    const history = await chatService.getConversationHistory(userId);\n    res.json(history);\n  } catch (error) {\n    next(error); // Pass to centralized error handler\n  }\n};\n```\n\n## 4. Code Style Rules\n\n### MUST Follow:\n*   **Consistent Formatting**:\n    *   **Rationale**: Ensures readability and reduces merge conflicts.\n    *   **Implementation**: Enforce Prettier and ESLint with a shared configuration. All code MUST pass linting and formatting checks.\n*   **Meaningful Naming**:\n    *   **Rationale**: Improves code comprehension and maintainability.\n    *   **Implementation**: Use descriptive names for variables, functions, components, and files.\n        *   Variables: `camelCase` (e.g., `chatMessage`, `userId`).\n        *   Functions: `camelCase` (e.g., `sendMessage`, `fetchUser`).\n        *   Components: `PascalCase` (e.g., `ChatMessage`, `AuthForm`).\n        *   Files: `kebab-case` for general files (e.g., `chat-service.ts`), `PascalCase` for React components (e.g., `Button.tsx`).\n*   **Immutability**:\n    *   **Rationale**: Prevents unexpected side effects and makes state changes predictable, especially in React.\n    *   **Implementation**: Avoid direct modification of objects or arrays. Use spread syntax (`...`), `map`, `filter`, `Object.assign`, etc., for updates.\n\n```typescript\n// MUST: Immutability\nconst updateMessage = (messages: Message[], id: string, newText: string) => {\n  return messages.map(msg => msg.id === id ? { ...msg, text: newText } : msg);\n};\n\n// MUST NOT: Mutability\n// const updateMessage = (messages: Message[], id: string, newText: string) => {\n//   const messageToUpdate = messages.find(msg => msg.id === id);\n//   if (messageToUpdate) {\n//     messageToUpdate.text = newText; // Direct modification\n//   }\n//   return messages;\n// };\n```\n\n*   **Concise Functions/Components**:\n    *   **Rationale**: Improves readability, testability, and reusability.\n    *   **Implementation**: Functions and components should ideally perform a single, well-defined task. Break down complex logic into smaller, focused units.\n*   **Environment Variables**:\n    *   **Rationale**: Securely manage sensitive information and allow easy configuration across environments.\n    *   **Implementation**: All API keys (OpenAI, Supabase), database credentials, and other configurable values MUST be stored in environment variables (e.g., `.env` files, Vercel/Render secrets). Never hardcode them.\n\n### MUST NOT Do:\n*   **Huge, Multi-Responsibility Modules**:\n    *   **Rationale**: Violates Single Responsibility Principle, makes code hard to understand, test, and maintain.\n    *   **Avoid**: A single file or module handling all authentication, chat, and user profile logic.\n    *   **Fix**: Separate logic by domain and layer (e.g., `auth.controller.ts`, `chat.service.ts`).\n*   **Complex State Management Patterns**:\n    *   **Rationale**: Introduces unnecessary boilerplate and complexity for a project using Zustand, which is designed for simplicity.\n    *   **Avoid**: Over-engineering global state with multiple reducers, selectors, and middleware if not strictly necessary.\n    *   **Fix**: Leverage Zustand's simple API for global state. Use React's `useState` or `useReducer` for local component state.\n*   **Direct DOM Manipulation in React**:\n    *   **Rationale**: Bypasses React's declarative rendering model, leading to unpredictable behavior and difficult debugging.\n    *   **Avoid**: Using `document.getElementById`, `querySelector`, etc., to directly modify the DOM within React components.\n    *   **Fix**: Use React state, refs (`useRef`), or conditional rendering to manage UI changes.\n\n```typescript\n// MUST NOT: Direct DOM manipulation\n// const MyComponent = () => {\n//   useEffect(() => {\n//     document.getElementById('my-element').style.display = 'none';\n//   }, []);\n//   return <div id=\"my-element\">...</div>;\n// };\n\n// MUST: Use React state or refs\nconst MyComponent = () => {\n  const [isVisible, setIsVisible] = useState(true);\n  return (\n    <div style={{ display: isVisible ? 'block' : 'none' }}>\n      <button onClick={() => setIsVisible(false)}>Hide</button>\n    </div>\n  );\n};\n```\n\n*   **Uncontrolled Components with Forms**:\n    *   **Rationale**: Makes form state difficult to manage and validate.\n    *   **Avoid**: Relying solely on `ref` for form inputs without managing state.\n    *   **Fix**: Use controlled components where input values are tied to React state.\n\n## 5. Architecture Patterns\n\n### Component/Module Structure Guidelines\n*   **Frontend (React)**:\n    *   **MUST**: Organize components into `features/` (for domain-specific components like `ChatWindow`, `AuthForm`) and `components/ui/` (for generic, reusable UI elements like `Button`, `Input`).\n    *   **MUST**: Keep components small and focused on a single responsibility.\n    *   **MUST**: Use `props` for communication between parent and child components.\n    *   **MUST NOT**: Create \"God Components\" that handle too many responsibilities.\n*   **Backend (Node.js)**:\n    *   **MUST**: Follow the `controller -> service -> (repository/client)` pattern for all business logic.\n    *   **Controller**: Handles request parsing, validation, and sending responses. Delegates business logic to services.\n    *   **Service**: Contains the core business logic, orchestrates calls to external APIs or database repositories.\n    *   **Repository/Client**: Abstracts database interactions (e.g., Supabase client calls) or external API calls (e.g., OpenAI API client).\n\n### Data Flow Patterns\n*   **Unidirectional Data Flow**:\n    *   **MUST**: Data flows primarily from parent components to child components via props in React. State changes trigger re-renders, propagating updates downwards.\n*   **Client-Server Communication**:\n    *   **MUST**: All client-to-server communication for core business logic (e.g., sending chat messages, fetching history) MUST go through the Node.js backend via RESTful API calls.\n    *   **MUST**: Direct Supabase Auth calls from the client are permissible for authentication workflows (login, signup).\n*   **Backend-External Services Interaction**:\n    *   **MUST**: The backend acts as a proxy for all external AI services (OpenAI, Sentiment API) to protect API keys and apply business logic/rate limiting.\n\n### State Management Conventions\n*   **Global State (Zustand)**:\n    *   **MUST**: Use Zustand for application-wide state that affects multiple, disparate components (e.g., user authentication status, global loading indicators, conversation history).\n    *   **MUST**: Define separate Zustand stores for distinct global concerns (e.g., `authStore.ts`, `chatStore.ts`).\n    *   **MUST**: Keep Zustand store logic minimal and focused on state updates. Complex derivations should be done at the component level or via Zustand selectors.\n*   **Local Component State**:\n    *   **MUST**: Use React's `useState` or `useReducer` for state that is only relevant to a single component or a small, co-located group of components.\n\n### API Design Standards\n*   **RESTful Principles**:\n    *   **MUST**: Design API endpoints following RESTful conventions (e.g., `/api/v1/chats`, `/api/v1/users`).\n    *   **MUST**: Use appropriate HTTP methods:\n        *   `GET`: Retrieve resources.\n        *   `POST`: Create new resources.\n        *   `PUT`/`PATCH`: Update existing resources.\n        *   `DELETE`: Remove resources.\n*   **JSON Format**:\n    *   **MUST**: All request and response bodies MUST be in JSON format.\n*   **Consistent Response Structure**:\n    *   **MUST**: Standardize API response structures for both success and error cases.\n\n```json\n// MUST: Success Response Structure\n{\n  \"data\": {\n    \"id\": \"chat-123\",\n    \"messages\": [\n      // ...\n    ]\n  },\n  \"metadata\": {\n    \"count\": 10,\n    \"nextCursor\": \"abc\"\n  }\n}\n\n// MUST: Error Response Structure\n{\n  \"error\": {\n    \"message\": \"Invalid input provided.\",\n    \"code\": \"VALIDATION_ERROR\",\n    \"details\": {\n      \"field\": \"message\",\n      \"reason\": \"Message cannot be empty\"\n    }\n  }\n}\n```\n\n*   **API Versioning**:\n    *   **MUST**: Include API versioning in the URL (e.g., `/api/v1/`). This allows for future breaking changes without affecting existing clients.\n*   **Input Validation**:\n    *   **MUST**: All API endpoints MUST validate incoming request data (e.g., using libraries like Zod or Joi) to ensure data integrity and security.",
      "writedAt": "2025-08-07T03:09:53.740Z"
    },
    {
      "type": "design-guide",
      "content": "# 韓国とも (Kankoku-Tomo) Design Guide\n\n## 1. Overall Mood (전체적인 무드)\n**신뢰할 수 있는 다정한 학습 파트너 (Trustworthy and Friendly Learning Partner)**\n\n서비스의 전반적인 무드는 전문성과 신뢰감을 기반으로 합니다. 중급 이상 학습자들이 깊이 있는 질문을 하고 정확한 답변을 기대하는 만큼, 차분하고 정돈된 디자인을 통해 학습에 집중할 수 있는 환경을 제공합니다. 동시에 '절친' 챗봇이라는 페르소나에 맞춰, 딱딱하지 않고 따뜻하며 정서적 유대감을 형성할 수 있는 부드럽고 친근한 감성을 더합니다. 차가운 기술이 아닌, 사용자와 함께 성장하는 다정한 파트너의 느낌을 전달하는 것이 핵심입니다.\n\n## 2. Reference Service (참조 서비스)\n참조 서비스로 Coursera를 선정했습니다. 신뢰감 있는 색상 사용과 명확하고 정돈된 정보 구조가 '韓国とも'가 지향하는 전문적 학습 경험에 부합합니다.\n\n- **Name**: Coursera\n- **Description**: 전 세계 유수 대학 및 기업의 강의를 제공하는 온라인 교육 플랫폼\n- **Design Mood**: 차분한 파란색을 중심으로 전문성과 신뢰감을 강조하며, 명확하고 정돈된 레이아웃으로 학습 효율을 높임\n- **Primary Color**: `#2A73CC`\n- **Secondary Color**: `#F3F7FB`\n\n## 3. Color & Gradient (색상 & 그라데이션)\n신뢰감을 주는 Cool Tone과 중-저채도 색상을 중심으로, 사용자가 편안함을 느끼고 학습에 집중할 수 있도록 컬러 시스템을 정의합니다.\n\n- **Primary Color**: `#2A73CC` (신뢰, 지성)\n- **Secondary Color**: `#F3F7FB` (차분함, 배경)\n- **Accent Color**: `#25304A` (강조, 가독성)\n- **Success/Positive Color**: `#3BAAAF` (성공, 긍정 피드백)\n- **Background Color**: `#F4F6F9` (전체 배경)\n- **Grayscale**:\n    - `Text`: `#333333`\n    - `Sub-text`: `#666666`\n    - `Border/Line`: `#DDDDDD`\n    - `Disabled`: `#CCCCCC`\n\n- **Mood**: Cool Tone, Mid-Low Saturation\n- **Color Usage**:\n    - **Primary**: 핵심 CTA 버튼, 활성화된 내비게이션, 링크, 사용자 채팅 버블 등 가장 중요한 인터랙션 요소에 사용합니다.\n    - **Secondary**: 챗봇 채팅 버블의 배경색으로 사용하여 사용자와 챗봇의 대화를 시각적으로 구분합니다.\n    - **Accent**: 주요 헤드라인 텍스트에 사용하여 정보의 위계를 명확히 합니다.\n    - **Background**: 전체 앱의 배경색으로 사용하여 눈의 피로를 줄이고 편안한 분위기를 조성합니다.\n    - **Grayscale**: 본문, 보조 텍스트, 비활성 요소 등에 사용하여 정보의 중요도를 조절하고 시각적 안정감을 줍니다.\n\n## 4. Typography & Font (타이포그래피 & 폰트)\n한국어와 일본어의 동시 사용성을 고려하여 가독성이 높은 폰트를 사용하고, 명확한 위계 시스템을 정의합니다.\n\n- **Font Family**: `Pretendard` (Korean), `Noto Sans JP` (Japanese), `sans-serif` (Fallback)\n- **Heading 1 (페이지 타이틀)**: Pretendard/Noto Sans JP, **28px**, **Bold (700)**\n- **Heading 2 (섹션 타이틀)**: Pretendard/Noto Sans JP, **22px**, **Bold (700)**\n- **Body (본문, 채팅 메시지)**: Pretendard/Noto Sans JP, **16px**, **Regular (400)**\n- **Sub-text (부가 정보, 캡션)**: Pretendard/Noto Sans JP, **14px**, **Regular (400)**\n- **Line Height**: `1.6` (본문 가독성 확보)\n- **Letter Spacing**: `0` (기본 설정)\n\n## 5. Layout & Structure (레이아웃 & 구조)\n사용자가 대화에 온전히 집중할 수 있도록 단순하고 일관된 레이아웃 구조를 채택합니다.\n\n- **Navigation**: 상단 고정 바 (Top Navigation Bar)\n    - 메뉴 수가 적고 (채팅, 대화 기록, 프로필) 채팅 인터페이스의 너비를 최대한 확보해야 하므로 상단 내비게이션이 가장 효율적입니다.\n- **Grid System**: 8px Grid System\n    - 모든 UI 요소의 간격과 크기를 8의 배수로 설정하여 디자인의 일관성과 질서를 유지합니다. (Base unit: 16px)\n- **Layout**: 단일 컬럼 레이아웃 (Single Column Layout)\n    - 메인 콘텐츠 영역은 채팅에 집중할 수 있도록 단일 컬럼으로 구성합니다. 넓은 화면에서는 최대 너비(max-width)를 약 `800px`로 제한하여 가독성을 확보합니다.\n- **Whitespace**: 충분한 여백 활용\n    - 요소 간 충분한 여백을 두어 시각적으로 편안하고 정돈된 느낌을 주며, 사용자가 정보에 집중하도록 돕습니다.\n\n## 6. Visual Style (비주얼 스타일)\n전문적이면서도 친근한 무드를 전달하기 위해 정제되고 일관된 비주얼 스타일을 정의합니다.\n\n- **Icons**:\n    - 스타일: 선(Outline) 스타일의 간결하고 현대적인 아이콘셋 (e.g., Feather Icons, Material Symbols)을 사용합니다.\n    - 목적: 서비스의 전문적이고 깔끔한 인상을 강화합니다.\n- **Illustrations**:\n    - 스타일: 온보딩, 빈 화면(Empty State) 등 필요한 경우에만 사용하며, 정의된 컬러 팔레트를 활용한 단순하고 따뜻한 스타일의 일러스트를 사용합니다. 과도하게 장식적인 요소는 지양합니다.\n- **Shadows & Borders**:\n    - 카드, 버튼, 채팅 버블 등에 미묘한 그림자(subtle shadow)를 사용하여 깊이감을 부여하고 컴포넌트를 구분합니다.\n    - 경계선은 연한 회색(`#DDDDDD`)을 사용하여 요소를 명확히 구분하되, 시각적 부담을 주지 않습니다.\n- **Corner Radius**:\n    - 버튼, 입력 필드, 카드 등 주요 컴포넌트에 `8px`의 일관된 둥근 모서리(corner radius)를 적용하여 부드럽고 현대적인 인상을 줍니다.\n\n## 7. UX Guide (UX 가이드)\n타겟 사용자의 특성과 목표에 맞춰 최적의 사용자 경험을 제공하기 위한 핵심 원칙을 정의합니다.\n\n- **전문가 중심의 명확성 (Clarity for Experts)**: 중급 이상 학습자를 위해 불필요한 단계를 최소화하고, 정보는 명확하고 밀도 있게 제공합니다. 키보드 단축키, 빠른 입력 등 효율성을 높이는 기능을 우선적으로 고려합니다.\n- **페르소나 기반의 상호작용 (Persona-Driven Interaction)**: 모든 챗봇의 응답과 시스템 메시지는 '다정하고 친절한 언니' 페르소나를 유지합니다. 항상 존댓말을 사용하며, 격려하고 지지하는 따뜻한 톤앤매너를 일관되게 적용합니다.\n- **끊김 없는 학습 흐름 (Seamless Learning Flow)**: `질문 → 답변 → 추가 학습 제안 → 복습`으로 이어지는 핵심 사용자 여정이 막힘없이 부드럽게 연결되도록 설계합니다. 사용자의 노력을 최소화하고 몰입을 유지하는 것을 최우선으로 합니다.\n- **정서적 안정감 제공 (Providing Emotional Safety)**: \"온라인 학습의 고립감\"이라는 Pain Point를 해결하기 위해, 챗봇의 공감 표현과 긍정적인 마이크로 인터랙션을 적극적으로 활용합니다. 사용자가 심리적 안정감을 느끼며 편안하게 질문할 수 있는 환경을 조성합니다.\n- **점진적 정보 공개 (Progressive Disclosure)**: 서비스가 처음인 사용자도 쉽게 적응할 수 있도록 친절한 온보딩과 가이드를 제공합니다. 고급 기능이나 명령어는 처음부터 노출하기보다, 사용자의 학습 단계에 맞춰 점진적으로 안내합니다.\n\n## 8. UI Component Guide (UI 컴포넌트 가이드)\n주요 UI 컴포넌트의 디자인 가이드를 구체적으로 명시하여 일관성을 확보합니다.\n\n- **Buttons (버튼)**\n    - **Primary CTA**: 배경은 Primary Color(`#2A73CC`)로 채우고 텍스트는 흰색으로 처리합니다. 마우스를 올리면(hover) 살짝 어두워지는 효과를 줍니다.\n    - **Secondary**: Primary Color로 외곽선을 그리고, 텍스트 역시 Primary Color를 사용합니다.\n    - **Chat Suggestion**: 챗봇의 제안 버튼은 Secondary 버튼 스타일을 따르거나, 더 가벼운 배경색(`#F3F7FB`)에 Primary Color 텍스트를 사용하여 대화의 흐름을 방해하지 않도록 합니다.\n\n- **Input Fields (입력 필드)**\n    - **Style**: 연한 회색(`_#DDDDDD_`)의 얇은 테두리와 `8px`의 둥근 모서리를 가집니다. 포커스 시 테두리 색상이 Primary Color로 변경되어 활성 상태를 명확히 알립니다.\n    - **Placeholder**: \"궁금한 한국어 표현을 물어보세요...\" 와 같이 사용자의 행동을 유도하는 친절한 안내 문구를 사용합니다.\n    - **Interaction**: '전송' 아이콘 버튼을 포함하며, 'Enter' 키로 메시지를 전송할 수 있습니다.\n\n- **Chat Bubbles (채팅 말풍선)**\n    - **User Bubble**: 오른쪽에 정렬하며, 배경색은 Primary Color(`#2A73CC`), 텍스트는 흰색을 사용합니다.\n    - **Chatbot Bubble**: 왼쪽에 정렬하며, 배경색은 Secondary Color(`#F3F7FB`), 텍스트는 Accent Color(`#25304A`)를 사용하여 사용자의 말풍선과 명확히 구분합니다.\n    - **Style**: `12px`의 둥근 모서리와 미묘한 그림자를 적용하여 입체감과 부드러움을 더합니다.\n\n- **Navigation Bar (상단 내비게이션)**\n    - **Style**: 흰색 또는 Background Color(`_#F4F6F9_`) 배경에 하단에 얇은 그림자나 경계선을 두어 콘텐츠 영역과 구분합니다.\n    - **Elements**: 좌측에 로고, 우측에 `대화`, `대화 기록`, `프로필/로그인` 메뉴를 배치합니다.\n    - **Active State**: 현재 활성화된 메뉴는 Primary Color 텍스트 또는 하단 밑줄로 표시하여 현재 위치를 명확하게 보여줍니다.\n\n- **Cards (대화 기록 카드)**\n    - **Style**: 흰색 배경, `8px` 둥근 모서리, 미묘한 테두리와 그림자를 적용하여 각 기록 항목을 구분합니다.\n    - **Content**: 대화 내용 일부, 타임스탬프, 즐겨찾기 아이콘을 표시합니다.\n    - **Hover State**: 마우스를 올리면 카드가 살짝 위로 올라오는 효과를 주어 인터랙션이 가능함을 암시합니다.",
      "writedAt": "2025-08-07T03:09:53.740Z"
    },
    {
      "type": "ia",
      "content": "# 韓国とも (Kankoku-Tomo) Information Architecture (IA)\n\n## 1. Site Map (사이트맵)\n서비스의 전체 페이지 구조를 체계적으로 표현합니다. 인증(로그인) 여부에 따라 접근 가능한 페이지를 구분합니다.\n\n- **Public (인증 불필요) / Landing**\n  - 서비스 소개 및 가입 유도 (`/`)\n  - 로그인 (`/auth/login`)\n  - 회원가입 (`/auth/signup`)\n\n- **Authenticated (인증 필요)**\n  - **채팅 (홈)** (`/chat`)\n    - *로그인 후 사용자가 가장 먼저 보게 되는 핵심 기능 페이지*\n  - **대화 기록** (`/history`)\n    - 대화 목록\n    - 대화 상세 보기 (모달 또는 개별 페이지)\n  - **프로필** (`/profile`)\n    - 내 정보 수정\n    - 학습 통계\n    - 설정\n\n- **Common (공통)**\n  - 이용약관\n  - 개인정보처리방침\n  - 문의하기/피드백\n\n## 2. User Flow (사용자 흐름)\n사용자가 핵심 과업을 완료하기 위해 거치는 경로를 설명합니다.\n\n**- 핵심 과업 1: 신규 사용자 가입 및 첫 질문하기**\n  1.  사용자가 랜딩 페이지(`'/'`)에 방문한다.\n  2.  [가입하기] CTA 버튼을 클릭하여 회원가입 페이지 (`/auth/signup`)로 이동한다.\n  3.  이메일, 비밀번호, 닉네임을 입력하고 [가입 완료] 버튼을 클릭한다.\n  4.  가입 완료 후, 온보딩 모달(서비스 특징 소개)을 확인한다.\n  5.  온보딩 종료 후 채팅 페이지 (`/chat`)로 자동 이동된다.\n  6.  채팅 입력창에 한국어 질문을 입력하고 '전송' 버튼을 클릭하거나 'Enter' 키를 누른다.\n  7.  시스템이 5초 내에 답변과 추가 예문을 제공한다.\n  8.  챗봇이 제안하는 추가 학습 질문(Suggestion Chip)을 클릭하여 대화를 이어간다.\n\n**- 핵심 과업 2: 기존 사용자의 대화 기록 복습하기**\n  1.  사용자가 서비스에 로그인하여 채팅 페이지 (`/chat`)에 접속한다.\n  2.  상단 네비게이션 바에서 [대화 기록] 메뉴를 클릭하여 대화 기록 페이지 (`/history`)로 이동한다.\n  3.  저장된 대화 목록을 스크롤하여 탐색하거나, 검색 필드를 이용해 특정 키워드가 포함된 대화를 찾는다.\n  4.  복습하고 싶은 대화 항목을 클릭한다.\n  5.  선택한 대화의 전체 내용이 모달(Modal) 창 또는 상세 뷰에 표시된다.\n  6.  사용자는 대화 내용을 다시 읽고, 중요한 예문에 [즐겨찾기] 아이콘을 클릭하여 표시한다.\n\n## 3. Navigation Structure (네비게이션 구조)\n서비스의 주요 탐색 시스템을 정의합니다. MVP 단계에서는 단순하고 명확한 상단 고정 내비게이션 바(Top Navigation Bar)를 사용합니다.\n\n- **Global Navigation Bar (GNB) - 상단 고정**\n  - **로그아웃 상태 (Public)**\n    - **좌측**: 로고 (클릭 시 랜딩 페이지 `/`로 이동)\n    - **우측**: [로그인], [회원가입] 버튼\n  - **로그인 상태 (Authenticated)**\n    - **좌측**: 로고 (클릭 시 채팅 페이지 `/chat`으로 이동)\n    - **우측**:\n      - **채팅**: `/chat` (현재 위치 활성화 표시)\n      - **대화 기록**: `/history`\n      - **프로필**: `/profile` (드롭다운으로 로그아웃 포함 가능)\n      - **언어 전환**: (JP/KO) 토글 버튼\n\n- **Footer (푸터)**\n  - 서비스 이용약관\n  - 개인정보처리방침\n  - 문의/피드백 링크\n  - © 韓国とも 2025\n\n## 4. Page Hierarchy (페이지 계층 구조)\n페이지 간의 부모-자식 관계를 들여쓰기로 표현하여 정보의 깊이를 정의합니다.\n\n- `/` (Depth 1, 랜딩 페이지)\n- `/auth` (Depth 1)\n  - `/auth/login` (Depth 2, 로그인)\n  - `/auth/signup` (Depth 2, 회원가입)\n- `/chat` (Depth 1, 핵심 채팅 기능)\n- `/history` (Depth 1, 대화 기록 목록)\n  - *`/history/:id` (Depth 2, 특정 대화 상세 - URL 직접 접근을 고려할 경우)*\n- `/profile` (Depth 1, 사용자 프로필 및 설정)\n\n## 5. Content Organization (콘텐츠 구성)\n주요 페이지에 포함될 핵심 콘텐츠 요소를 정의합니다.\n\n| 페이지 | 핵심 콘텐츠 요소 |\n| --- | --- |\n| **Landing (`/`)** | - **Hero Section**: 서비스 핵심 가치 제안(\"절친 챗봇과 나누는 진짜 한국어 대화\"), CTA 버튼([무료로 시작하기])<br>- **Feature List**: 실시간 Q&A, 대화 기록 저장, 감성 케어 등 핵심 기능 소개<br>- **Testimonials**: (향후) 사용자 후기 |\n| **Chat (`/chat`)** | - **Chat Window**: 사용자 메시지 버블, 챗봇 응답 버블, 예문 카드<br>- **Chat Input Form**: 텍스트 입력 필드, 전송 버튼<br>- **Suggestion Chips**: 챗봇이 제안하는 추가 질문 버튼<br>- **Onboarding Modal**: (최초 방문 시) 서비스 사용법 안내 |\n| **History (`/history`)** | - **Search/Filter Bar**: 키워드 검색, 날짜 필터<br>- **Conversation List**: 개별 대화 요약 카드(날짜, 내용 일부, 즐겨찾기 여부)<br>- **Conversation Detail Modal**: 클릭 시 나타나는 전체 대화 내용 뷰<br>- **Empty State**: 저장된 대화가 없을 때 표시되는 안내 메시지와 일러스트 |\n| **Profile (`/profile`)** | - **User Info Card**: 닉네임, 이메일 주소, [수정] 버튼<br>- **Learning Stats Section**: 총 질문 수, 연속 학습일 등 학습 통계 데이터<br>- **Settings Section**: 알림 설정, 언어 설정, [로그아웃] 버튼, [회원 탈퇴] 링크 |\n\n## 6. Interaction Patterns (인터랙션 패턴)\n서비스 전반에서 일관되게 사용될 공통 인터랙션 패턴을 정의합니다.\n\n- **Modal**: 대화 상세 보기, 온보딩 가이드, 설정 변경 확인 등 현재 페이지의 맥락을 벗어나지 않으면서 추가 정보나 과업을 제공할 때 사용합니다.\n- **Tooltip**: 아이콘 버튼(예: 즐겨찾기, 발음 듣기) 위에 마우스를 올렸을 때 기능에 대한 짧은 설명을 제공합니다.\n- **Chips**: 챗봇의 추가 질문 제안처럼, 사용자가 선택할 수 있는 여러 옵션을 간결하게 제시할 때 사용합니다.\n- **Real-time Feedback**: 채팅 입력 시, 시스템이 응답을 생성하는 동안 로딩 인디케이터(e.g., \"입력 중...\")를 표시하여 시스템 상태를 명확히 전달합니다.\n- **Toast/Snackbar**: 즐겨찾기 추가, 정보 저장 성공 등 사용자의 액션에 대한 짧고 가벼운 피드백을 화면 하단이나 상단에 잠시 노출합니다.\n\n## 7. URL Structure (URL 구조)\n사용자 가독성과 검색 엔진 최적화(SEO)를 고려한 일관된 URL 구조를 정의합니다.\n\n- **서비스 소개**: `/`\n- **인증**: `/auth/login`, `/auth/signup`\n- **핵심 기능**: `/chat`\n- **리소스 목록**: `/history`\n- **리소스 상세**: `/history/:conversationId` (공유 및 직접 접근을 위해 모달과 별개로 URL 정의)\n- **사용자 정보**: `/profile`\n\n## 8. Component Hierarchy (컴포넌트 계층 구조)\n페이지를 구성하는 재사용 가능한 컴포넌트의 계층을 정의하여 디자인 및 개발의 일관성을 확보합니다.\n\n- **Global Components (전역 컴포넌트)**\n  - `Header`: 로고, 네비게이션 메뉴(GNB) 포함\n  - `Footer`: 법적 고지 및 링크 포함\n  - `Button`: Primary, Secondary, Icon Button 등 다양한 형태의 버튼\n  - `InputField`: 텍스트 입력 필드\n  - `Modal`: 배경 오버레이를 포함한 모달 래퍼\n\n- **Feature / Page-specific Components (기능 및 페이지별 컴포넌트)**\n  - **Chat Page**\n    - `ChatWindow`: 전체 채팅 인터페이스 컨테이너\n      - `MessageBubble`: 사용자 및 챗봇 메시지 말풍선\n      - `ExampleCard`: 챗봇이 제공하는 예문 카드\n      - `SuggestionChip`: 챗봇의 대화 제안 버튼\n    - `ChatInput`: 메시지 입력 및 전송 폼\n  - **History Page**\n    - `ConversationList`: 대화 목록을 렌더링하는 컨테이너\n      - `ConversationListItem`: 개별 대화 요약 카드\n    - `ConversationDetailView`: 선택된 대화의 전체 내용을 보여주는 뷰 (모달 내부에 위치)\n  - **Profile Page**\n    - `UserProfileCard`: 사용자 정보 표시 카드\n    - `StatsDisplay`: 학습 통계 시각화 컴포넌트",
      "writedAt": "2025-08-07T03:09:53.740Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-07T03:09:53.740Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-07T03:09:53.740Z"
    }
  ]
}