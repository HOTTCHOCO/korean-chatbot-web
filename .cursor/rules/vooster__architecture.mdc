---
description:
globs:
alwaysApply: true
---
# Technical Requirements Document (TRD): 韓国とも (Kankoku-Tomo) v0.1

## 1. Executive Technical Summary
- **Project Overview**: '韓国とも(Kankoku-Tomo)'는 일본인 중급 한국어 학습자를 위한 웹 기반 AI 챗봇 서비스입니다. React 기반의 단일 페이지 애플리케이션(SPA)과 Node.js/Express 백엔드 서버를 통해 신속한 개발과 배포를 지향합니다. 백엔드 인프라는 Supabase를 활용하여 데이터베이스, 인증, 실시간 기능을 통합 관리함으로써 개발 복잡성을 최소화하고 운영 효율성을 극대화합니다.
- **Core Technology Stack**: 프론트엔드는 React, 백엔드는 Node.js와 Express를 사용합니다. 데이터베이스와 인증은 Supabase(PostgreSQL)가 담당하며, 핵심 AI 기능은 OpenAI의 GPT-4o API를 활용합니다.
- **Key Technical Objectives**:
    - **응답 속도**: 사용자의 질문에 대해 5초 이내에 AI 답변을 제공합니다.
    - **안정성**: 99% 이상의 서비스 가동 시간을 목표로 합니다.
    - **확장성**: 초기 DAU 50명을 무리 없이 처리하고, 향후 사용자 증가에 유연하게 대응할 수 있는 아키텍처를 구축합니다.
- **Critical Technical Assumptions**:
    - OpenAI GPT-4o API의 응답 속도와 품질이 사용자의 기대치를 충족합니다.
    - Supabase의 무료/저가 플랜이 MVP 단계의 트래픽과 데이터 저장 요구사항을 충분히 감당할 수 있습니다.
    - 웹 표준 기술(Web Speech API)이 주요 타겟 브라우저(Chrome, Safari)에서 안정적으로 동작합니다.

## 2. Tech Stack

| Category | Technology / Library | Reasoning (Why it's chosen for this project) |
|---|---|---|
| **Frontend** | React, Vite | 컴포넌트 기반 아키텍처로 UI 개발 및 유지보수가 용이하며, 생태계가 활성화되어 있습니다. Vite는 빠른 개발 서버와 최적화된 빌드 성능을 제공합니다. |
| **Backend** | Node.js, Express.js | 프론트엔드와 동일한 JavaScript/TypeScript 언어를 사용하여 풀스택 개발 생산성을 높입니다. 가볍고 최소한의 구성으로 REST API를 빠르게 구축할 수 있습니다. |
| **Database & Auth** | Supabase (PostgreSQL) | 관리형 PostgreSQL 데이터베이스와 인증(Auth), 스토리지 기능을 통합 제공하여 백엔드 개발 리소스를 크게 절감합니다. 실시간 기능(Realtime)을 통해 향후 기능 확장이 용이합니다. |
| **AI / ML** | OpenAI GPT-4o API | 사용자의 질문에 대한 자연스럽고 정확한 답변 및 예문 생성을 위해 검증된 최신 언어 모델을 사용합니다. |
| **AI / ML (감정 분석)** | 외부 Sentiment Analysis API (예: Vercel AI SDK 연동) | 챗봇의 응답에 감성적 깊이를 더하기 위해 전문 API를 활용합니다. Vercel AI SDK와 통합하여 구현을 단순화합니다. |
| **Deployment** | Vercel (Frontend), Render (Backend) | Git과 연동된 자동 CI/CD 파이프라인을 통해 배포를 자동화합니다. Vercel은 React 앱 배포에 최적화되어 있고, Render는 Node.js 서버와 PostgreSQL(Supabase 연동) 환경을 손쉽게 구성할 수 있습니다. |
| **State Management** | Zustand | 가볍고 직관적인 API를 제공하여 React 상태 관리를 단순화합니다. Boilerplate 코드가 적어 소규모 프로젝트에 적합합니다. |

## 3. System Architecture Design

### Top-Level building blocks
- **Client (React Web App)**: 사용자가 직접 상호작용하는 웹 애플리케이션입니다. 사용자 인터페이스(UI), 상태 관리, 사용자 입력을 처리합니다.
    - **Sub-building blocks**: Chat Interface, Authentication Pages (Login/Signup), Conversation History View.
- **Backend (Node.js API Server)**: 비즈니스 로직을 처리하고 외부 서비스와의 통신을 중계하는 서버입니다. 클라이언트와 데이터베이스 사이의 게이트웨이 역할을 합니다.
    - **Sub-building blocks**: REST API Endpoints, OpenAI API Integration Logic, User Session Management.
- **BaaS (Supabase)**: 백엔드 핵심 기능을 제공하는 서비스형 백엔드(Backend-as-a-Service)입니다. 데이터베이스, 사용자 인증, 파일 스토리지를 담당합니다.
    - **Sub-building blocks**: PostgreSQL Database, User Authentication, Row Level Security (RLS).
- **External AI Services**: 서비스의 핵심 지능을 제공하는 외부 API입니다.
    - **Sub-building blocks**: OpenAI API, Sentiment Analysis API.

### Top-Level Component Interaction Diagram
```mermaid
graph TD
    subgraph Browser
        User[사용자]
    end

    subgraph Vercel
        Client[React Web App]
    end

    subgraph Render
        Backend[Node.js API Server]
    end
    
    subgraph External Services
        OpenAI[OpenAI GPT-4o API]
        Sentiment[Sentiment Analysis API]
    end

    subgraph Supabase Cloud
        Auth[Supabase Auth]
        DB[PostgreSQL Database]
    end

    User -- Interacts with --> Client
    Client -- REST API Calls (질문, 기록 조회) --> Backend
    Client -- Auth Requests (로그인, 가입) --> Auth
    Backend -- AI Query --> OpenAI
    Backend -- Sentiment Analysis --> Sentiment
    Backend -- DB Operations (대화 저장/조회) --> DB
```

- 사용자는 Vercel에 배포된 React 웹 앱과 상호작용합니다.
- 로그인/회원가입과 같은 인증 요청은 클라이언트에서 직접 Supabase Auth로 전송되어 처리됩니다.
- 채팅 메시지 전송과 같은 핵심 기능 요청은 Render에 배포된 Node.js 백엔드 서버로 전달됩니다.
- 백엔드 서버는 OpenAI API와 Sentiment API를 호출하여 AI 응답을 생성하고, 대화 내용을 Supabase 데이터베이스에 저장/조회합니다.

### Code Organization & Convention
**Domain-Driven Organization Strategy**
- **Domain Separation**: 비즈니스 도메인(예: 채팅, 사용자, 기록)을 기준으로 코드를 구성하여 응집도를 높이고 결합도를 낮춥니다.
- **Layer-Based Architecture**: 각 도메인 내부는 Presentation(Controller), Business Logic(Service), Data Access(Repository) 계층으로 분리하여 관심사를 명확히 합니다.
- **Feature-Based Modules**: 프론트엔드는 기능 단위(예: `features/chat`, `features/auth`)로 컴포넌트, 상태, 훅을 그룹화합니다.
- **Shared Components**: 여러 도메인에서 공통으로 사용되는 유틸리티, 타입 정의, UI 컴포넌트는 `shared` 또는 `lib` 디렉토리에서 관리합니다.

**Universal File & Folder Structure**
```
/
├── frontend/ (React Client)
│   ├── src/
│   │   ├── api/             # API 호출 함수
│   │   ├── assets/          # 이미지, 폰트
│   │   ├── components/      # 재사용 가능한 UI 컴포넌트 (Atoms, Molecules)
│   │   │   ├── ui/          # Headless UI 기반의 기본 컴포넌트
│   │   │   └── layout/      # 페이지 레이아웃
│   │   ├── features/        # 기능별 도메인 폴더
│   │   │   ├── auth/        # 인증 관련 컴포넌트, 훅
│   │   │   └── chat/        # 채팅 관련 컴포넌트, 훅, 상태
│   │   ├── hooks/           # 공용 커스텀 훅
│   │   ├── pages/           # 라우팅 단위 페이지
│   │   ├── store/           # 전역 상태 관리 (Zustand)
│   │   └── App.tsx
│   └── package.json
│
├── backend/ (Node.js Server)
│   ├── src/
│   │   ├── common/          # 공통 모듈 (미들웨어, 유틸리티)
│   │   ├── config/          # 환경변수, 설정
│   │   ├── domains/         # 비즈니스 도메인별 폴더
│   │   │   ├── chat/
│   │   │   │   ├── chat.controller.ts # HTTP 요청/응답 처리
│   │   │   │   ├── chat.service.ts    # 비즈니스 로직
│   │   │   │   └── chat.router.ts     # 라우팅 설정
│   │   │   └── user/
│   │   ├── lib/             # 외부 서비스 연동 클라이언트 (OpenAI)
│   │   └── server.ts        # 서버 진입점
│   └── package.json
```

### Data Flow & Communication Patterns
- **Client-Server Communication**: 클라이언트와 백엔드 서버 간의 통신은 HTTPS 기반의 RESTful API를 통해 이루어지며, 데이터 형식은 JSON을 사용합니다.
- **Database Interaction**: 백엔드 서버는 Supabase 클라이언트 라이브러리 또는 Prisma와 같은 ORM을 사용하여 PostgreSQL 데이터베이스와 상호작용합니다. 데이터 접근 시 Supabase의 RLS(Row Level Security) 정책을 준수하여 사용자별 데이터 격리를 보장합니다.
- **External Service Integration**: 백엔드 서버가 클라이언트를 대신하여 OpenAI, Sentiment API 등을 호출하는 프록시 역할을 수행합니다. 이를 통해 API Key와 같은 민감한 정보를 안전하게 관리합니다.
- **Real-time Communication**: MVP에서는 실시간 통신이 필수적이지 않으나, 향후 기능 확장 시 Supabase Realtime 또는 WebSocket을 도입하여 "상대방 입력 중..."과 같은 기능을 구현할 수 있습니다.
- **Data Synchronization**: 사용자 인증 상태는 Supabase Auth가 발급하는 JWT(JSON Web Token)를 통해 클라이언트와 서버 간에 동기화됩니다. 대화 기록은 필요시 API를 통해 명시적으로 조회합니다.

## 4. Performance & Optimization Strategy

- **AI 응답 속도 최적화**: OpenAI API 호출 시 `stream: true` 옵션을 사용하여 응답을 스트리밍 방식으로 수신합니다. 이를 통해 사용자는 전체 답변이 생성될 때까지 기다리지 않고, 생성되는 텍스트를 실시간으로 볼 수 있어 체감 속도를 크게 향상시킬 수 있습니다.
- **프론트엔드 로딩 성능 개선**: React.lazy와 Suspense를 활용하여 코드 스플리팅을 적용합니다. 초기 로딩에 필요하지 않은 컴포넌트(예: 대화 기록 페이지)는 사용자가 해당 페이지로 이동할 때 동적으로 로드하여 초기 번들 크기를 줄입니다.
- **데이터베이스 쿼리 효율화**: 대화 기록을 조회하는 쿼리에 `user_id`와 `created_at` 필드를 기준으로 인덱스(Index)를 생성하여 대량의 데이터가 쌓여도 빠른 조회 성능을 보장합니다.
- **정적 자산 캐싱**: Vercel의 글로벌 CDN(Content Delivery Network)을 활용하여 이미지, CSS, JS 파일과 같은 정적 자산을 사용자에게 가장 가까운 엣지 로케이션에서 제공함으로써 로딩 속도를 단축합니다.

## 5. Implementation Roadmap & Milestones
### Phase 1: Foundation (MVP Implementation)
- **Core Infrastructure**: Supabase 프로젝트 생성, 데이터베이스 스키마(users, conversations, messages) 설계, Vercel/Render 배포 환경 구성.
- **Essential Features**:
    - 이메일 기반 회원가입 및 로그인 (Supabase Auth 연동)
    - 실시간 Q&A 채팅 인터페이스 구현
    - 백엔드를 통한 OpenAI GPT-4o API 연동 (질문->답변+예문)
    - 대화 로그 저장 및 재열람 기능
- **Basic Security**: Supabase RLS를 설정하여 사용자는 자신의 대화 기록만 접근 가능하도록 제한. API Key 등 민감 정보는 환경변수로 관리.
- **Development Setup**: Git 레포지토리 생성, 프론트엔드/백엔드 개발 환경 구축, CI/CD 파이프라인 설정.
- **Timeline**: 2.5주 (PRD의 8/7 ~ 8/20 일정 준수)

### Phase 2: Feature Enhancement
- **Advanced Features**:
    - 감정 분석 API를 연동하여 챗봇의 공감 반응 기능 구현
    - Web Speech API를 활용한 음성 입력 기능 기술 검토 및 프로토타입 개발
- **Performance Optimization**: MVP 운영 데이터 기반으로 느린 API 엔드포인트 및 DB 쿼리 튜닝. 프론트엔드 번들 사이즈 분석 및 최적화.
- **Enhanced Security**: 서드파티 라이브러리 보안 취약점 점검(npm audit), API 요청 속도 제한(Rate Limiting) 도입.
- **Monitoring Implementation**: AWS CloudWatch 또는 유사 모니터링 툴을 연동하여 API 응답 시간, 에러율, 서버 리소스 사용량에 대한 대시보드 및 알림 설정.
- **Timeline**: MVP 출시 후 1개월 내

## 6. Risk Assessment & Mitigation Strategies
### Technical Risk Analysis
- **Technology Risks**:
    - **위험**: OpenAI API의 응답 지연 또는 비용 급증. 챗봇의 페르소나(따뜻한 말투)를 일관되게 유지하기 위한 프롬프트 엔지니어링의 복잡성.
    - **완화 전략**: API 호출에 합리적인 타임아웃(Timeout)을 설정하고, 스트리밍 응답을 적용하여 체감 성능을 개선합니다. 비용 모니터링 알림을 설정하고, 프롬프트는 버전 관리하여 지속적으로 개선합니다.
- **Performance Risks**:
    - **위험**: 사용자 및 대화 데이터 증가 시 대화 기록 조회 성능 저하.
    - **완화 전략**: 데이터베이스 `user_id`, `conversation_id`에 인덱스를 적용하고, 페이지네이션(Pagination)을 구현하여 한 번에 불러오는 데이터 양을 제한합니다.
- **Security Risks**:
    - **위험**: Supabase RLS 정책 설정 오류로 인한 데이터 유출. 악의적인 API 요청으로 인한 서비스 장애 또는 비용 발생.
    - **완화 전략**: RLS 정책에 대한 코드 리뷰 및 테스트를 강화합니다. 백엔드 API에 요청량 제한(Rate Limiting)을 적용하여 DoS 공격을 방지합니다.
- **Integration Risks**:
    - **위험**: 외부 API(OpenAI, Sentiment)의 장애 또는 정책 변경으로 인한 서비스 중단.
    - **완화 전략**: API 호출 로직에 서킷 브레이커(Circuit Breaker) 패턴을 적용하여 장애 전파를 막고, "죄송해요, 지금은 답변하기 어려워요"와 같은 안정적인 폴백(Fallback) 메시지를 사용자에게 안내합니다.

### Project Delivery Risks
- **Timeline Risks**:
    - **위험**: 2.5주라는 공격적인 MVP 개발 일정으로 인한 기능 구현 지연.
    - **완화 전략**: Supabase와 같은 BaaS를 적극 활용하여 백엔드 개발 공수를 최소화하고, MVP 범위에서 우선순위가 낮은 기능(예: 정교한 감정 분석)은 과감히 제외합니다.
- **Resource Risks**:
    - **위험**: 프롬프트 엔지니어링, Supabase RLS 등 특정 기술에 대한 팀의 경험 부족.
    - **완화 전략**: 공식 문서와 커뮤니티를 적극 활용하고, 복잡한 로직은 구현 전에 간단한 PoC(Proof of Concept)를 통해 기술을 검증합니다.
- **Quality Risks**:
    - **위험**: 빠른 개발 속도로 인한 코드 품질 저하 및 버그 발생 가능성.
    - **완화 전략**: 인증, 채팅 메시지 처리 등 핵심 로직에 대한 단위 테스트 및 통합 테스트 코드를 작성합니다. 동료 간 코드 리뷰를 의무화하여 잠재적 결함을 조기에 발견합니다.
- **Deployment Risks**:
    - **위험**: 개발 환경과 운영 환경의 차이로 인한 배포 후 예상치 못한 오류 발생.
    - **완화 전략**: Vercel/Render의 개발, 프리뷰, 프로덕션 환경을 분리하여 사용하고, 주요 변경 사항은 프리뷰 환경에서 충분히 검증한 후 프로덕션에 배포합니다.
